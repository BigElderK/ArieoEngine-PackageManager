#!/usr/bin/env python3
"""
ArieoEngine Package Initializer
Handles downloading packages and generating package resolve file with dependency resolution
"""

import json
import os
import subprocess
import sys
from pathlib import Path
from collections import defaultdict
import yaml


def gather_dependencies(package_names, packages):
    """
    Recursively gather all dependencies for given packages
    
    Args:
        package_names: List of package names to gather dependencies for
        packages: Dict of all packages from resolve file
        
    Returns:
        set: Set of package names including dependencies
    """
    result = set()
    
    def add_package_with_deps(pkg_name):
        if pkg_name in result or pkg_name not in packages:
            return
        
        result.add(pkg_name)
        
        # Get dependencies
        pkg_info = packages[pkg_name]
        dependencies = pkg_info.get('dependencies', [])
        
        # Recursively add dependencies
        for dep in dependencies:
            dep_name = dep.get('name')
            if dep_name:
                add_package_with_deps(dep_name)
    
    for pkg_name in package_names:
        add_package_with_deps(pkg_name)
    
    return result


def generate_cmake_file(output_path, package_resolve_file_path, package_filter=None, include_dependencies=False):
    """
    Generate a CMake file using ExternalProject_Add for all packages with dependencies
    
    Args:
        output_path: Path where to save the generated CMake file
        package_resolve_file_path: Path to the resolve file (package.lock.json or packages_resolve.json)
        package_filter: Optional list of package names to include (includes all if None)
        include_dependencies: If True, includes dependencies of filtered packages
    """
    try:
        with open(package_resolve_file_path, 'r', encoding='utf-8') as f:
            resolve_data = json.load(f)
    except Exception as e:
        error_msg = f"✗ Error: Failed to read package resolve file: {e}"
        print(error_msg)
        sys.exit(1)
    
    install_order = resolve_data.get('install_order', [])
    packages = resolve_data.get('packages', {})
    
    # Filter packages if requested
    if package_filter:
        missing_packages = [pkg for pkg in package_filter if pkg not in packages]
        if missing_packages:
            error_msg = f"✗ Error: Package(s) not found in resolve file: {', '.join(missing_packages)}"
            print(error_msg)
            print(f"  Available: {', '.join(packages.keys())}")
            sys.exit(1)
        
        if include_dependencies:
            packages_to_include = gather_dependencies(package_filter, packages)
            deps_only = sorted(packages_to_include - set(package_filter))
            if deps_only:
                print(f"Including dependencies: {', '.join(deps_only)}")
        else:
            packages_to_include = set(package_filter)
        
        install_order = [pkg for pkg in install_order if pkg in packages_to_include]
    
    # Sort packages by build_index to ensure correct build order
    install_order.sort(key=lambda pkg_name: packages[pkg_name].get('build_index', 999))
    
    # Extract root-level environment variables
    root_env_vars = {}
    root_public_env_vars = {}
    root_private_env_vars = {}
    root_env_vars_list = resolve_data.get('environment_variables', [])
    for env_var in root_env_vars_list:
        env_type = env_var.get('type', 'public')
        env_name = env_var.get('name')
        env_value = env_var.get('value')
        if env_name and env_value:
            root_env_vars[env_name] = env_value
            if env_type == 'public':
                root_public_env_vars[env_name] = env_value
            else:
                root_private_env_vars[env_name] = env_value
    
    # Generate CMake file
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    print(f"\n{'='*60}")
    print(f"GENERATING CMAKE FILE")
    print(f"{'='*60}")
    print(f"Output file: {output_file.resolve()}")
    print(f"Packages to include: {len(install_order)}")
    
    with open(output_file, 'w', encoding='utf-8') as f:
        # Write header
        f.write("# This file is auto-generated by ArieoEngine Package Manager\n")
        f.write("# Do not edit manually\n\n")
        f.write("cmake_minimum_required(VERSION 3.31)\n")
        f.write("project(ArieoEngineSuperBuild)\n\n")
        f.write("include(ExternalProject)\n\n")
        
        # Write root environment variables
        if root_env_vars:
            f.write("# Root-level environment variables\n")
            for env_name, env_value in root_env_vars.items():
                # Convert paths to use forward slashes for cross-platform compatibility
                if isinstance(env_value, str) and ('\\' in env_value or ':' in env_value):
                    try:
                        env_value = Path(env_value).as_posix()
                    except:
                        pass  # If conversion fails, use original value
                f.write(f'set({env_name} \"{env_value}\" CACHE STRING \"{env_name} from package manifest\")\n')
            f.write("\n")
        
        # Build dependency map with recursive dependencies
        dependency_map = {}
        
        def gather_recursive_deps(pkg_name, visited=None):
            """Recursively collect all dependencies for a package"""
            if visited is None:
                visited = set()
            
            result = []
            if pkg_name not in packages:
                return result
            
            pkg_info = packages[pkg_name]
            dependencies = pkg_info.get('dependencies', [])
            
            for dep in dependencies:
                dep_name = dep.get('name')
                if dep_name and dep_name in install_order and dep_name not in visited:
                    visited.add(dep_name)
                    # Add dependencies of this dependency first (depth-first)
                    result.extend(gather_recursive_deps(dep_name, visited))
                    # Then add the dependency itself
                    if dep_name not in result:
                        result.append(dep_name)
            
            return result
        
        for pkg_name in install_order:
            # Get all recursive dependencies
            all_deps = gather_recursive_deps(pkg_name)
            dependency_map[pkg_name] = all_deps
        
        # Write ExternalProject_Add for each package
        for idx, pkg_name in enumerate(install_order, 1):
            pkg_info = packages[pkg_name]
            
            print(f"  [{idx}/{len(install_order)}] Adding {pkg_name}")
            
            # Use local source (already downloaded by init_packages.py)
            source_folder = pkg_info.get('source_folder')
            git_url = pkg_info.get('git_url')
            
            # Build directory (use actual path from resolve file, keep cmake variables as-is)
            build_folder = pkg_info.get('build_folder')
            if build_folder:
                # Don't resolve - build_folder may contain ${CMAKE_CONFIGURE_PRESET}
                abs_build = build_folder
            
            # Install directory (use actual path from resolve file, keep cmake variables as-is)
            install_folder = pkg_info.get('install_folder')
            if install_folder:
                # Don't resolve - install_folder may contain ${CMAKE_CONFIGURE_PRESET}
                abs_install = install_folder
            
            # Dependencies
            deps = dependency_map.get(pkg_name, [])
            
            # Package-specific environment variables
            package_env_vars = {}
            package_public_env_vars = {}
            package_private_env_vars = {}
            environment_variables = pkg_info.get('environment_variables', [])
            for env_var in environment_variables:
                env_type = env_var.get('type', 'public')
                env_name = env_var.get('name')
                env_value = env_var.get('value')
                if env_name and env_value:
                    # Convert paths to use forward slashes for cross-platform compatibility
                    if isinstance(env_value, str) and ('\\' in env_value or ':' in env_value):
                        try:
                            env_value = Path(env_value).as_posix()
                        except:
                            pass  # If conversion fails, use original value
                    package_env_vars[env_name] = env_value
                    if env_type == 'public':
                        package_public_env_vars[env_name] = env_value
                    else:
                        package_private_env_vars[env_name] = env_value
            
            # Gather public environment variables from all dependency packages recursively
            dep_public_env_vars = {}
            
            def gather_dep_env_vars(dep_pkg_name, visited=None):
                if visited is None:
                    visited = set()
                if dep_pkg_name in visited:
                    return
                visited.add(dep_pkg_name)
                
                if dep_pkg_name not in packages:
                    return
                
                dep_pkg_info = packages[dep_pkg_name]
                dep_env_vars = dep_pkg_info.get('environment_variables', [])
                
                # Add only public environment variables
                for env_var in dep_env_vars:
                    env_type = env_var.get('type', 'public')
                    if env_type == 'public':
                        env_name = env_var.get('name')
                        env_value = env_var.get('value')
                        if env_name and env_value:
                            # Convert paths to use forward slashes
                            if isinstance(env_value, str) and ('\\' in env_value or ':' in env_value):
                                try:
                                    env_value = Path(env_value).as_posix()
                                except:
                                    pass
                            dep_public_env_vars[env_name] = env_value
                
                # Recursively gather from dependencies of this dependency
                dep_deps = dependency_map.get(dep_pkg_name, [])
                for nested_dep in dep_deps:
                    gather_dep_env_vars(nested_dep, visited)
            
            # Gather from all direct dependencies
            for dep_pkg in deps:
                gather_dep_env_vars(dep_pkg)
            
            # Check if package has ArieoPackage.yaml to determine build system
            source_path = Path(source_folder) if source_folder else None
            has_arieo_package = source_path and (source_path / "ArieoPackage.yaml").exists()
            
            if not has_arieo_package:
                error_msg = f"✗ Error: ArieoPackage.yaml not found in package '{pkg_name}' at {source_path}"
                print(error_msg)
                sys.exit(1)
            
            # Get cmake_presets_file from package info
            cmake_presets_file = pkg_info.get('cmake_presets_file', '')
            
            # Write comment first
            f.write(f"# Package {idx}/{len(install_order)}: {pkg_name}\n")
            
            # Write set() commands ONLY for package's own public environment variables
            # (root and dependency variables are already set elsewhere)
            for var_name, var_value in package_public_env_vars.items():
                # Ensure paths use forward slashes
                if isinstance(var_value, str) and ('\\' in var_value or ':' in var_value):
                    try:
                        var_value = Path(var_value).as_posix()
                    except:
                        pass
                f.write(f"set({var_name} \"{var_value}\")\n")
            
            # Collect all public variables for reference in CMAKE_CACHE_ARGS
            all_public_vars = {}
            all_public_vars.update(root_public_env_vars)
            all_public_vars.update(dep_public_env_vars)
            all_public_vars.update(package_public_env_vars)
            
            # Now write ExternalProject_Add
            f.write(f"ExternalProject_Add(\n")
            f.write(f"    {pkg_name}\n")
            
            if source_folder:
                # Use absolute path for source folder
                abs_source = Path(source_folder).resolve().as_posix()
                if git_url:
                    f.write(f"    # Local source (downloaded from Git: {git_url})\n")
                else:
                    f.write(f"    # Local source\n")
                f.write(f"    SOURCE_DIR \"{abs_source}\"\n")
            
            f.write(f"    \n")
            
            if build_folder:
                f.write(f"    # Build directory\n")
                f.write(f"    BINARY_DIR \"{abs_build}\"\n")
            
            if install_folder:
                f.write(f"    # Install directory\n")
                f.write(f"    INSTALL_DIR \"{abs_install}\"\n")
            
            f.write(f"    \n")
            
            if deps:
                f.write(f"    # Dependencies\n")
                f.write(f"    DEPENDS")
                for dep in deps:
                    f.write(f"\n        {dep}")
                f.write(f"\n    \n")
            
            # Update options
            f.write(f"    # Update options\n")
            f.write(f"    UPDATE_COMMAND \"\"\n")
            f.write(f"    \n")
            f.write(f"    BUILD_ALWAYS TRUE\n")
            f.write(f"    \n")
            # Use terminal for build/install/configure to stream output in real-time
            f.write(f"    USES_TERMINAL_CONFIGURE TRUE\n")
            f.write(f"    USES_TERMINAL_BUILD TRUE\n")
            f.write(f"    USES_TERMINAL_INSTALL TRUE\n")
            f.write(f"    \n")
            
            # Collect environment variables for CMAKE_CACHE_ARGS
            # Only include private variables since public ones are set via CONFIGURE_ENVIRONMENT_MODIFICATION
            all_env_vars_for_cache = {}
            
            # Add cmake_presets_file if available
            if cmake_presets_file:
                all_env_vars_for_cache['CMAKE_PRESETS_FILE'] = cmake_presets_file
            
            # Add only PRIVATE environment variables (root, dependency, and package)
            for env_name, env_value in root_private_env_vars.items():
                # Convert paths to use forward slashes for cross-platform compatibility
                if isinstance(env_value, str) and ('\\' in env_value or ':' in env_value):
                    try:
                        env_value = Path(env_value).as_posix()
                    except:
                        pass
                all_env_vars_for_cache[env_name] = env_value
            
            for env_name, env_value in package_private_env_vars.items():
                # Convert paths to use forward slashes
                if isinstance(env_value, str) and ('\\' in env_value or ':' in env_value):
                    try:
                        env_value = Path(env_value).as_posix()
                    except:
                        pass
                all_env_vars_for_cache[env_name] = env_value
            
            # Pass private environment variables as CMAKE_CACHE_ARGS
            if all_env_vars_for_cache:
                f.write(f"    # CMAKE_CACHE_ARGS are passed to the configuration stage (cmake command)\n")
                f.write(f"    CMAKE_CACHE_ARGS\n")
                for env_name, env_value in all_env_vars_for_cache.items():
                    f.write(f"        -D{env_name}:STRING={env_value}\n")
                f.write(f"    \n")
            
            # Add CMAKE_ARGS
            f.write(f"    # CMAKE_ARGS are passed to the configuration stage (cmake command)\n")
            f.write(f"    CMAKE_ARGS\n")
            
            # Add generator if specified
            generator = pkg_info.get('generator', '')
            if generator:
                f.write(f"        -G \"{generator}\"\n")
            
            # Add --preset if package has cmake_presets_file
            if cmake_presets_file:
                f.write(f"        --preset=${{CMAKE_CONFIGURE_PRESET}}\n")
            
            # Generate variable name for this package's install folder
            package_name = pkg_name.upper().replace('-', '_').replace('ARIEOENGINE_', '').replace('ARIEO_', '')
            install_folder_var = f'ARIEO_{package_name}_PACKAGE_INSTALL_FOLDER'
            
            f.write(f"        -DCMAKE_BUILD_TYPE=${{CMAKE_BUILD_TYPE}}\n")
            f.write(f"        -DCMAKE_INSTALL_PREFIX=${{{install_folder_var}}}\n")
            f.write(f"        -DCMAKE_CONFIGURE_PRESET=${{CMAKE_CONFIGURE_PRESET}}\n")
            
            # Add CONFIGURE_ENVIRONMENT_MODIFICATION for packages that need preset environment variables
            # Collect all public environment variables from root and dependencies
            env_mod_vars = {}
            env_mod_vars.update(root_public_env_vars)
            env_mod_vars.update(dep_public_env_vars)
            
            # Add CMAKE_PREFIX_PATH from all dependency packages' install folders as environment variable
            # This allows child projects to append to CMAKE_PREFIX_PATH without overriding preset values
            # Store paths separately to use cmake_list_append operation
            prefix_path_entries = []
            if deps:
                for dep_pkg in deps:
                    if dep_pkg in packages:
                        # Generate variable name from package name
                        dep_var_name = dep_pkg.upper().replace('-', '_').replace('ARIEOENGINE_', '').replace('ARIEO_', '')
                        output_var_name = f'ARIEO_{dep_var_name}_PACKAGE_INSTALL_FOLDER'
                        prefix_path_entries.append(f'${{{output_var_name}}}')
            
            # Only add CONFIGURE_ENVIRONMENT_MODIFICATION if there are variables to set
            if env_mod_vars or prefix_path_entries:
                f.write(f"\n    CONFIGURE_ENVIRONMENT_MODIFICATION\n")
                # First, set all regular environment variables
                for env_name in sorted(env_mod_vars.keys()):
                    f.write(f"        {env_name}=set:${{{env_name}}}\n")
                # Then, append each dependency path to CMAKE_EXTRA_PREFIX_PATH using cmake_list_append
                for prefix_path in prefix_path_entries:
                    f.write(f"        ARIEO_CMAKE_EXTRA_PREFIX_PATH=cmake_list_append:{prefix_path}\n")
            
            # Add PATCH_COMMAND to copy cmake_presets_file if present
            if cmake_presets_file:
                # Replace $ENV{VAR} with ${VAR} for CMake variable syntax
                cmake_presets_path = cmake_presets_file.replace('$ENV{', '${')
                f.write(f"\n    PATCH_COMMAND ${{CMAKE_COMMAND}} -E copy {cmake_presets_path} <SOURCE_DIR>/CMakeUserPresets.json\n")
            
            # Add BUILD_COMMAND if defined in ArieoPackage.yaml
            build_commands = pkg_info.get('build_commands', [])
            if build_commands:
                # First command goes on same line as BUILD_COMMAND
                # Additional commands use COMMAND keyword
                f.write(f"\n    BUILD_COMMAND {build_commands[0]}\n")
                for cmd in build_commands[1:]:
                    f.write(f"    COMMAND       {cmd}\n")
            
            # Add INSTALL_COMMAND if defined in ArieoPackage.yaml
            install_commands = pkg_info.get('install_commands', [])
            if install_commands:
                # First command goes on same line as INSTALL_COMMAND
                # Additional commands use COMMAND keyword
                f.write(f"\n    INSTALL_COMMAND {install_commands[0]}\n")
                for cmd in install_commands[1:]:
                    f.write(f"    COMMAND         {cmd}\n")
            
            f.write(f")\n\n")
    
    print(f"\n✓ CMake file generated successfully: {output_file.resolve()}")
    print(f"{'='*60}\n")


def download_package_from_git(git_url, tag, dest_folder, category=None):
    """
    Clone a git repository and checkout specific tag/branch
    
    Args:
        git_url: Git repository URL
        tag: Tag or branch name to checkout
        dest_folder: Destination folder path
        category: Optional category subfolder (e.g., "00_build")
    
    Returns:
        dict: Contains 'folder_name' (relative path with category) and 'repo_name'
    """
    dest_path = Path(dest_folder)
    if category:
        dest_path = dest_path / category
    
    # Extract repository name from git URL
    repo_name = git_url.rstrip('/').split('/')[-1].replace('.git', '')
    # Append tag to folder name
    repo_folder_name = f"{repo_name}-{tag}"
    repo_path = dest_path / repo_folder_name
    
    print(f"Downloading package: {repo_name} (tag: {tag})")
    print(f"  URL: {git_url}")
    print(f"  Tag/Branch: {tag}")
    print(f"  Destination: {repo_path}")
    
    try:
        # Create destination folder if it doesn't exist
        dest_path.mkdir(parents=True, exist_ok=True)
        
        # Check if repository already exists
        if repo_path.exists():
            print(f"  Repository already exists, updating...")
            # Change to repo directory and pull
            original_cwd = os.getcwd()
            os.chdir(repo_path)
            
            # Fetch latest changes
            subprocess.run(['git', 'fetch', '--all'], check=True, capture_output=True)
            
            # Checkout the specified tag/branch
            result = subprocess.run(['git', 'checkout', tag], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"  Warning: Could not checkout {tag}: {result.stderr}")
            
            # Pull latest if it's a branch
            subprocess.run(['git', 'pull'], capture_output=True)
            
            os.chdir(original_cwd)
            print(f"✓ Updated {repo_folder_name}")
            
            # Return relative path with category if provided
            if category:
                return {'folder_name': f"{category}/{repo_folder_name}", 'repo_name': repo_name}
            else:
                return {'folder_name': repo_folder_name, 'repo_name': repo_name}
        else:
            # Clone the repository
            result = subprocess.run(
                ['git', 'clone', git_url, str(repo_path)],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                error_msg = f"✗ Failed to clone repository: {repo_name}\nError: {result.stderr}"
                print(error_msg)
                sys.exit(1)
            
            # Checkout the specified tag/branch
            original_cwd = os.getcwd()
            os.chdir(repo_path)
            
            result = subprocess.run(['git', 'checkout', tag], capture_output=True, text=True)
            if result.returncode != 0:
                print(f"  Warning: Could not checkout {tag}: {result.stderr}")
            
            os.chdir(original_cwd)
            print(f"✓ Downloaded {repo_folder_name}")
        
        # Return relative path with category if provided
        if category:
            return {'folder_name': f"{category}/{repo_folder_name}", 'repo_name': repo_name}
        else:
            return {'folder_name': repo_folder_name, 'repo_name': repo_name}
        
    except Exception as e:
        error_msg = f"✗ Error downloading package: {repo_name}\nException: {str(e)}"
        print(error_msg)
        sys.exit(1)


def read_arieo_package_yaml(package_path):
    """
    Read ArieoPackage.yaml from a package folder
    
    Args:
        package_path: Path to the package folder
        
    Returns:
        dict: Package data or None if not found
    """
    arieo_package_yaml_path = Path(package_path) / "ArieoPackage.yaml"
    
    if not arieo_package_yaml_path.exists():
        print(f"  Warning: ArieoPackage.yaml not found in {package_path}")
        return None
    
    try:
        with open(arieo_package_yaml_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f) or {}
    except Exception as e:
        error_msg = f"✗ Error: Failed to read ArieoPackage.yaml in {package_path}: {e}"
        print(error_msg)
        sys.exit(1)


def check_dependency_conflicts(packages_data):
    """
    Check for version/tag conflicts in dependencies
    
    Args:
        packages_data: Dict mapping package name to package info
        
    Returns:
        None (exits on conflict)
    """
    # Track required versions for each dependency
    dependency_requirements = defaultdict(dict)  # {dep_name: {pkg_name: tag}}
    
    for pkg_name, pkg_info in packages_data.items():
        arieo_data = pkg_info.get('arieo_package_data')
        if not arieo_data:
            continue
            
        dependencies = arieo_data.get('dependencies', {})
        dep_packages = dependencies.get('packages', [])
        
        for dep in dep_packages:
            dep_git_url = dep.get('git_url', '')
            dep_tag = dep.get('tag', 'main')
            dep_name = dep_git_url.rstrip('/').split('/')[-1].replace('.git', '')
            
            dependency_requirements[dep_name][pkg_name] = dep_tag
    
    # Check for conflicts
    conflicts = []
    for dep_name, requirements in dependency_requirements.items():
        if len(set(requirements.values())) > 1:
            # Multiple different versions required
            conflicts.append((dep_name, requirements))
    
    if conflicts:
        error_msg = "✗ Error: Dependency version/tag conflicts detected!\n\n"
        for dep_name, requirements in conflicts:
            error_msg += f"Package '{dep_name}' has conflicting version requirements:\n"
            for pkg_name, tag in requirements.items():
                error_msg += f"  - Required by '{pkg_name}' with tag/version: '{tag}'\n"
            error_msg += "\n"
        
        error_msg += "Please resolve these conflicts by ensuring all packages depend on the same version/tag."
        print(error_msg)
        sys.exit(1)


def topological_sort(packages_data):
    """
    Perform topological sort on packages based on dependencies
    
    Args:
        packages_data: Dict mapping package name to package info
        
    Returns:
        list: Ordered list of package names
    """
    # Build dependency graph
    in_degree = defaultdict(int)
    graph = defaultdict(list)
    
    # Initialize all packages with in_degree 0
    for pkg_name in packages_data:
        in_degree[pkg_name] = 0
    
    # Build graph
    for pkg_name, pkg_info in packages_data.items():
        arieo_data = pkg_info.get('arieo_package_data')
        if not arieo_data:
            continue
            
        dependencies = arieo_data.get('dependencies', {})
        dep_packages = dependencies.get('packages', [])
        
        for dep in dep_packages:
            dep_git_url = dep.get('git_url', '')
            dep_name = dep_git_url.rstrip('/').split('/')[-1].replace('.git', '')
            
            if dep_name in packages_data:
                graph[dep_name].append(pkg_name)
                in_degree[pkg_name] += 1
    
    # Topological sort using Kahn's algorithm
    queue = [pkg for pkg in packages_data if in_degree[pkg] == 0]
    result = []
    
    while queue:
        current = queue.pop(0)
        result.append(current)
        
        for neighbor in graph[current]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check for circular dependencies
    if len(result) != len(packages_data):
        error_msg = "✗ Error: Circular dependency detected!"
        print(error_msg)
        sys.exit(1)
    
    return result


def load_manifest(manifest_file_path=None):
    """
    Load package manifest file (YAML format)
    
    Args:
        manifest_file_path: Optional path to manifest file. If not provided, uses "package.manifest.yaml"
    
    Returns:
        dict: Manifest data or None if failed
    """
    if not manifest_file_path:
        yaml_path = Path("package.manifest.yaml")
        
        if yaml_path.exists():
            manifest_path = yaml_path
        else:
            error_msg = "✗ Error: package.manifest.yaml not found"
            print(error_msg)
            sys.exit(1)
    else:
        manifest_path = Path(manifest_file_path)
        if not manifest_path.exists():
            error_msg = f"✗ Error: Manifest file not found at {manifest_path}"
            print(error_msg)
            sys.exit(1)
    
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            manifest = yaml.safe_load(f) or {}
            manifest['_manifest_dir'] = str(manifest_path.parent.resolve())
            return manifest
    except Exception as e:
        error_msg = f"✗ Error: Failed to read manifest file: {e}"
        print(error_msg)
        sys.exit(1)


def generate_package_resolve_file(install_order, packages_data, packages_src_folder, packages_install_folder, packages_build_folder, package_resolve_file_path):
    """
    Generate package resolve file (package.lock.json or packages_resolve.json) with installation order and package details
    
    Args:
        install_order: List of package names in installation order
        packages_data: Dict mapping package name to package info
        packages_src_folder: Source folder path
        packages_install_folder: Output folder path
        packages_build_folder: Output folder path for build outputs
        package_resolve_file_path: Path where to write the resolve file
        
    Returns:
        str: Path to generated resolve file
    """
    resolve_data = {
        "generated_at": subprocess.run(['date', '/T'], capture_output=True, text=True, shell=True).stdout.strip() if os.name == 'nt' else subprocess.run(['date'], capture_output=True, text=True).stdout.strip(),
        "packages_src_folder": Path(packages_src_folder).resolve().as_posix(),
        "packages_install_folder": Path(packages_install_folder).resolve().as_posix(),
        "packages_build_folder": Path(packages_build_folder).resolve().as_posix(),
        "environment_variables": [],
        "install_order": [],
        "packages": {}
    }
    
    # Build resolve data
    for idx, pkg_name in enumerate(install_order, 1):
        pkg_info = packages_data[pkg_name]
        arieo_data = pkg_info.get('arieo_package_data') or {}
        
        # Get the package name from ArieoPackage.yaml, fallback to repo name
        package_name = arieo_data.get('name', pkg_name)
        
        # Generate normalized variable name from package name
        pkg_var_name = package_name.upper().replace('-', '_').replace('ARIEOENGINE_', '').replace('ARIEO_', '')
        
        cmake_presets_file = arieo_data.get('cmake_presets_file', '')
        
        # Get category from ArieoPackage.yaml or derive from folder structure
        folder_name_path = Path(pkg_info['folder_name'])
        category = arieo_data.get('category', '')
        if not category:
            category = folder_name_path.parent.as_posix() if folder_name_path.parent.as_posix() != '.' else ''
        
        # Resolve build_folder from ArieoPackage.yaml
        build_folder_yaml = arieo_data.get('build_folder', '')
        if not build_folder_yaml:
            error_msg = f"✗ FATAL: 'build_folder' is not set in ArieoPackage.yaml for package '{package_name}' at {pkg_info['path']}"
            print(error_msg)
            sys.exit(1)
        
        build_folder_path = build_folder_yaml
        build_folder_path = build_folder_path.replace('${ARIEO_PACKAGE_INSTALL_FOLDER}', Path(packages_build_folder).resolve().as_posix())
        build_folder_path = build_folder_path.replace('${ARIEO_PACKAGE_CATEGORY}', category)
        build_folder_path = build_folder_path.replace('${ARIEO_PACKAGE_NAME}', package_name)
        
        # Resolve install_folder from ArieoPackage.yaml
        install_folder_yaml = arieo_data.get('install_folder', '')
        if not install_folder_yaml:
            error_msg = f"✗ FATAL: 'install_folder' is not set in ArieoPackage.yaml for package '{package_name}' at {pkg_info['path']}"
            print(error_msg)
            sys.exit(1)
        
        install_folder_path = install_folder_yaml
        install_folder_path = install_folder_path.replace('${ARIEO_PACKAGE_INSTALL_FOLDER}', Path(packages_install_folder).resolve().as_posix())
        install_folder_path = install_folder_path.replace('${ARIEO_PACKAGE_CATEGORY}', category)
        install_folder_path = install_folder_path.replace('${ARIEO_PACKAGE_NAME}', package_name)
        
        package_entry = {
            "build_index": idx,
            "name": package_name,
            "description": arieo_data.get('description', ''),
            "git_url": pkg_info.get('git_url', ''),
            "tag": pkg_info.get('tag', ''),
            "source_folder": pkg_info['path'].resolve().as_posix(),
            "build_folder": build_folder_path,
            "install_folder": install_folder_path,
            "cmake_presets_file": cmake_presets_file,
            "environment_variables": [
                {
                    "type": "public",
                    "name": 'ARIEO_' + pkg_var_name + '_PACKAGE_BUILD_FOLDER',
                    "value": build_folder_path
                },
                {
                    "type": "public",
                    "name": 'ARIEO_' + pkg_var_name + '_PACKAGE_INSTALL_FOLDER',
                    "value": install_folder_path
                },
                {
                    "type": "private",
                    "name": 'CUR_PROCESSING_ARIEO_PACKAGE_NAME',
                    "value": package_name
                }
            ],
            "build_commands": arieo_data.get('build_commands', []),
            "install_commands": arieo_data.get('install_commands', []),
            "generator": arieo_data.get('generator', ''),
            "dependencies": []
        }
        
        # Extract dependencies
        dependencies = arieo_data.get('dependencies', {})
        dep_packages = dependencies.get('packages', [])
        for dep in dep_packages:
            dep_url = dep.get('git_url', '')
            dep_tag = dep.get('tag', 'main')
            dep_name = dep_url.rstrip('/').split('/')[-1].replace('.git', '')
            package_entry['dependencies'].append({
                "name": dep_name,
                "git_url": dep_url,
                "tag": dep_tag
            })
        
        resolve_data['install_order'].append(package_name)
        resolve_data['packages'][package_name] = package_entry
    
    # Write resolve file
    package_resolve_file_path = Path(package_resolve_file_path)
    try:
        # Create output folder if it doesn't exist
        package_resolve_file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(package_resolve_file_path, 'w', encoding='utf-8') as f:
            json.dump(resolve_data, f, indent=4, ensure_ascii=False)
        print(f"✓ Generated {package_resolve_file_path.resolve()}")
        return str(package_resolve_file_path.resolve())
    except Exception as e:
        error_msg = f"✗ Error: Failed to write resolve file: {e}"
        print(error_msg)
        sys.exit(1)


def init_all_packages(manifest_file_path=None):
    """
    Download all packages from package.manifest.yaml with dependency resolution
    
    Args:
        manifest_file_path: Optional path to manifest file
    """
    manifest = load_manifest(manifest_file_path)
    
    manifest_dir = Path(manifest.get('_manifest_dir', '.')).resolve()

    def expand_manifest_path(value):
        if not value:
            return value
        expanded = value.replace('${CUR_MANIFEST_FILE_DIR}', str(manifest_dir))
        expanded = os.path.expandvars(expanded)
        return expanded

    packages_src_folder = expand_manifest_path(manifest.get('packages_src_folder', './_packages/src'))
    packages_install_folder = expand_manifest_path(manifest.get('packages_install_folder', './_packages/published'))
    packages_build_folder = expand_manifest_path(manifest.get('packages_build_folder', './_output'))
    packages_resolve_file = expand_manifest_path(manifest.get('packages_resolve_file', str(Path(packages_install_folder) / 'package.lock.json')))
    packages_cmake_list_file = expand_manifest_path(manifest.get('packages_cmake_list_file'))
    packages_raw = manifest.get('packages', {})
    
    # Support both old format (dict with categories) and new format (flat list)
    # New format: packages is a list, category comes from ArieoPackage.yaml
    # Old format: packages is a dict with category keys
    if isinstance(packages_raw, list):
        # New flat list format
        packages_list = packages_raw
        use_flat_list = True
    else:
        # Old dict format - flatten to list
        packages_list = []
        for category, pkg_list in packages_raw.items():
            for pkg in pkg_list:
                pkg['_manifest_category'] = category  # Store category from manifest temporarily
                packages_list.append(pkg)
        use_flat_list = False
    
    total_packages = len(packages_list)
    
    if total_packages == 0:
        print("No packages to download")
        return
    
    print(f"\\n{'='*60}")
    print(f"STEP 1: Downloading {total_packages} package(s)")
    print(f"{'='*60}")
    
    # Download all packages first
    packages_data = {}
    pkg_counter = 0
    
    for package in packages_list:
        pkg_counter += 1
        git_url = package.get('git_url')
        git_spec = package.get('git')
        local_path_raw = package.get('local')
        tag = package.get('tag', 'main')
        
        # Parse git@tag format if present
        if git_spec:
            if '@' in git_spec:
                git_url, tag = git_spec.rsplit('@', 1)
            else:
                git_url = git_spec
                tag = 'main'
        
        if local_path_raw:
            local_path = Path(expand_manifest_path(local_path_raw))
            if not local_path.is_absolute():
                local_path = (manifest_dir / local_path).resolve()
            if not local_path.exists():
                error_msg = f"✗ Error: Local package path not found: {local_path}"
                print(error_msg)
                sys.exit(1)

            repo_name = local_path.name
            package_path = local_path
            git_url = None
            tag = 'local'
            
            # Read ArieoPackage.yaml first to get category
            arieo_data = read_arieo_package_yaml(package_path)
            if use_flat_list:
                # Get category from ArieoPackage.yaml
                category = arieo_data.get('category', '') if arieo_data else ''
            else:
                # Get category from manifest (old format)
                category = package.get('_manifest_category', '')
            
            repo_folder_name = f"{category}/{repo_name}" if category else repo_name
            print(f"\\nProcessing package {pkg_counter}/{total_packages}: {repo_name} [Category: {category}]")
            print(f"  Using local package path: {local_path}")
        else:
            if not git_url:
                error_msg = f"✗ Error: Package #{pkg_counter} missing git_url or local"
                print(error_msg)
                sys.exit(1)

            # For git packages, download first then read ArieoPackage.yaml
            # Get category from manifest for old format, or download first and read for new format
            if use_flat_list:
                # Download to temp location first to read category
                result = download_package_from_git(git_url, tag, packages_src_folder, '')
                temp_folder_name = result['folder_name']
                repo_name = result['repo_name']
                package_path = Path(packages_src_folder) / temp_folder_name
                
                # Read ArieoPackage.yaml to get category
                arieo_data = read_arieo_package_yaml(package_path)
                category = arieo_data.get('category', '') if arieo_data else ''
                
                # Move to correct category folder if needed
                if category:
                    new_folder_name = f"{category}/{result['folder_name'].split('/')[-1]}"
                    new_path = Path(packages_src_folder) / new_folder_name
                    if package_path != new_path:
                        new_path.parent.mkdir(parents=True, exist_ok=True)
                        if new_path.exists():
                            import shutil
                            shutil.rmtree(new_path)
                        package_path.rename(new_path)
                        package_path = new_path
                    repo_folder_name = new_folder_name
                else:
                    repo_folder_name = temp_folder_name
            else:
                # Old format - category from manifest
                category = package.get('_manifest_category', '')
                result = download_package_from_git(git_url, tag, packages_src_folder, category)
                repo_folder_name = result['folder_name']
                repo_name = result['repo_name']
                package_path = Path(packages_src_folder) / repo_folder_name
                arieo_data = read_arieo_package_yaml(package_path)
            
            print(f"\\nProcessing package {pkg_counter}/{total_packages}: {repo_name} [Category: {category}]")
        
        packages_data[repo_name] = {
            'git_url': git_url,
            'tag': tag,
            'path': package_path,
            'folder_name': repo_folder_name,  # Includes category in path
            'arieo_package_data': arieo_data
        }
    
    print(f"\\n{'='*60}")
    print(f"STEP 2: Resolving dependencies")
    print(f"{'='*60}")
    
    # Check for version/tag conflicts
    check_dependency_conflicts(packages_data)
    
    # Perform topological sort to determine installation order
    install_order = topological_sort(packages_data)
    
    print(f"\n{'='*60}")
    print(f"STEP 3: Generating package resolve file")
    print(f"{'='*60}")
    
    # Generate resolve file with installation details
    package_resolve_file_path = generate_package_resolve_file(install_order, packages_data, packages_src_folder, packages_install_folder, packages_build_folder, packages_resolve_file)
    
    # Display installation order
    print(f"\nBuild order:")
    for idx, pkg_name in enumerate(install_order, 1):
        pkg_info = packages_data[pkg_name]
        arieo_data = pkg_info.get('arieo_package_data')
        
        # Show source information in parentheses
        if pkg_info.get('git_url'):
            source_info = f"Git URL: {pkg_info['git_url']}, Tag: {pkg_info['tag']}"
        else:
            source_info = f"Local: {pkg_info['path'].resolve()}"
        
        print(f"  {idx}. {pkg_name} ({source_info})")
        
        # Show dependencies
        if arieo_data:
            dependencies = arieo_data.get('dependencies', {})
            dep_packages = dependencies.get('packages', [])
            if dep_packages:
                print(f"     Dependencies:")
                for dep in dep_packages:
                    dep_url = dep.get('git_url', 'unknown')
                    dep_name = dep_url.rstrip('/').split('/')[-1].replace('.git', '')
                    print(f"       - {dep_name}")
    
    return package_resolve_file_path, packages_cmake_list_file


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(
        description='ArieoEngine Package Initializer - Downloads packages and generates package resolve file',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        '--manifest',
        dest='manifest_file',
        default=None,
        help='Path to package.manifest.yaml (optional, defaults to package.manifest.yaml in current directory)'
    )
    
    args = parser.parse_args()
    
    # Download and generate resolve file for all packages from manifest
    print("ArieoEngine Package Initializer")
    print("=" * 60)
    
    package_resolve_file_path, packages_cmake_list_file = init_all_packages(args.manifest_file)
    
    print(f"\n{'='*60}")
    print("✓ All packages downloaded and resolve file generated")
    print(f"{'='*60}")
    
    # Generate CMake file if configured in manifest
    if packages_cmake_list_file:
        generate_cmake_file(packages_cmake_list_file, package_resolve_file_path, package_filter=None, include_dependencies=True)
    
    sys.exit(0)
